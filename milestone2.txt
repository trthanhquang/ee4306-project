DesktopJoystick    joystick1
	/Procedure_UpdateAxes:proc1
	/Procedure_UpdateButtons:proc2

UpdateCameraView  
	/EyePosition:0 40 -20  	/LookAtPoint:0 0 0

ImportScript  
	/FileName:"Script/ee4306-project/circle_wall.txt"

//Vehicle 1
	AddDifferentialDriveEntity    car1
		/Orientation:0    180    0
		/Position: 6   0    -5
		/Mass: 10
	AddLaserRangeFinderEntity    lrf_front
		/Position:0  0.15  -0.25
		/ParentEntity:car1
		/Procedure_SensorNotify: laser_read
	
	AddCompassEntity    compass1
		/Position:-0.1  0.15  -0.25
		/ParentEntity:car1
		/Procedure_SensorNotify: compass_read

FlushScript 

INF = 1000000

robot1 = false
robot2 = false
robot3 = false

//Compass global variable
compass_reading = 0
compassRaw = 0

CarWidth = 0.313
HeadingTole = 0.01

//Laser global variables
leftAngle = 0
rightAngle = 0
leftDist =50000
rightDist = 50000
frontDist = 50000
leftBackDist = 50000
rangeData = Util.CreateArrayDouble(361)
laserReadFlag = 0

//global variables for planeScanner
planeStartingIndex = Util.CreateArrayDouble(10)
planeEndingIndex = Util.CreateArrayDouble(10)
planePerDist = Util.CreateArrayDouble(10)

//getCarSpeed
leftCarDist = 0
rightCarDist = 0

dvLeftCar = 0
dvRightCar = 0
dpLeftCar = 0
dpRightCar = 0

dvFront = 0
dpFront = 0
//smoothGo variables
temp = 0
leftWheel = 0
rightWheel = 0
z0 = 0
z1 = 0
middlePoint = 0

// speed - power constant (speed = power x constant)
kv = 1.56

//waypoints
waypoint_X = Util.CreateArrayDouble(6)
waypoint_Z = Util.CreateArrayDouble(6)


WaitForEntityCreation    car1
wait 1000
print "3"
wait 1000
print "2"
wait 1000
print "1"
wait 1000
print "GO!"

//call initZwaypoint()
call initNormalwaypoint()
call runAround() 

Procedure getWaypointDist(index)
{
	pX = car1.Position.X
	pZ= car1.Position.Z
	wX = waypoint_X[index]
	wZ = waypoint_Z[index]
	dist = Math.Sqrt ((pX-wX)*(pX-wX) + (pZ-wZ)*(pZ-wZ))
	//print "pX: "+pX + ", pZ: "+pZ+", wX: "+wX+", wZ: " +wZ+" --> dist: "+dist
	return dist
}
End

Procedure initZwaypoint(){
	waypoint_X[0]=5.5
	waypoint_Z[0]=0
	
	waypoint_X[1]=5.5
	waypoint_Z[1]=-10
	
	waypoint_X[2]=0
	waypoint_Z[2]=5.5
	
	waypoint_X[3]= -5.5
	waypoint_Z[3]= -10
	
	waypoint_X[4]= -5.5
	waypoint_Z[4]= 0
	
	waypoint_X[5]= 0
	waypoint_Z[5]= -15.5
}
End 

Procedure initNormalwaypoint(){
	waypoint_X[0]=5.5
	waypoint_Z[0]=0
	
	waypoint_X[1]=5.5
	waypoint_Z[1]=-10
	
	waypoint_X[2]=0
	waypoint_Z[2]=-15.5
	
	waypoint_X[3]= -5.5
	waypoint_Z[3]= -10
	
	waypoint_X[4]= -5.5
	waypoint_Z[4]= 0
	
	waypoint_X[5]= 0
	waypoint_Z[5]= 5.5
}
End 
Procedure getWaypointDirection(index)
{
	pX = car1.Position.X
	pZ= car1.Position.Z
	wX = waypoint_X[index]
	wZ = waypoint_Z[index]
	
	vX = wX - pX
	vZ = wZ - pZ
	th = (Math.Atan (-vX/vZ)*180/Math.PI)
	if(vZ > 0)
		if(vX > 0)
			th = th +180
		else
			th = th - 180

	compass = (compassRaw / Math.PI * 180)
	dth = th - compass
	if (dth > 180)
		dth = dth - 360
	if (dth < (-180))
		dth = dth + 360

	pX = Util.ToInt(10.0* pX)/10.0
	pZ = Util.ToInt(10.0* pZ)/10.0
	vX = Util.ToInt(10.0* vX)/10.0
	vZ = Util.ToInt(10.0* vZ)/10.0
	th = Util.ToInt(10.0* th)/10.0
	compass = Util.ToInt(10.0* compass)/10.0
	dth = Util.ToInt(10.0* dth)/10.0
	print "pX: "+pX + ",pZ: "+pZ+ ", vX: " +vX +",vZ: "+vZ+", th = "+th + ",compass: "+ compass+", dth = "+dth
	return dth
{
End

Procedure runAround()
	while (true) {
		for( i= 0 ; i< 6; i++){
			print "------------------------------------------------"
			print "getting to waypoint "+i+" (" + waypoint_X[i]+","+waypoint_Z[i]+")"
			call getWaypointDirection(i)

			if(Math.Abs (getWaypointDirection) > 120){
				print "Change direction"
				car1.Stop()
				wait 1000
				car1.Turn(-150,0.2)
			}

			call getWaypointDist(i)
			while (getWaypointDist > 1)
			{
				//print "distance to waypoint "+i+": " + getWaypointDist
				call wallFollow(0.6, 0.7)
				wait 10
				call getWaypointDist(i)
			}
			pX = car1.Position.X
			pZ = car1.Position.Z
			pX = Util.ToInt(1000.0* pX)/1000.0
			pZ = Util.ToInt(1000.0* pZ)/1000.0
			print "reached waypoint "+i+" (" + pX+","+pZ+")"
		}
	}
End

Procedure wallFollow(goalDist, basePower)
	Kh = 0.5 / 90.0;
	Kd = 0.3;
	angularMax = 0.07
	lateralMax = 0.05

	angularError = Util.ToInt (1000.0* leftAngle)/1000.0
	angularOutput = Kh*angularError;

	if(angularOutput > angularMax)
		angularOutput = angularMax
	if(angularOutput < (-angularMax))
		angularOutput = -angularMax
	
	lateralError = Util.ToInt( 1000.0 *( goalDist - leftDist))/1000.0;
	lateralOutput = Kd*lateralError

	if(lateralOutput > lateralMax)
		lateralOutput = lateralMax
	if(lateralOutput < (-lateralMax))
		lateralOutput = -lateralMax

	leftPower = basePower + angularOutput + lateralOutput
	rightPower = basePower - angularOutput - lateralOutput

	leftPower = Util.ToInt (1000.0* leftPower) / 1000.0
	rightPower = Util.ToInt (1000.0* rightPower) / 1000.0
	angularOutput = Util.ToInt (1000.0* angularOutput) / 1000.0
	lateralOutput = Util.ToInt (1000.0* lateralOutput) / 1000.0

//	print "(" + leftPower + " " + rightPower+ ") aErr: "+ angularError+", laErr: "+ lateralError + ", aOut: " + angularOutput + ",laOut: "+ lateralOutput
//	print "laErr: "+ lateralError + ", aErr: "+ angularError+ ", laOut: "+ lateralOutput + ", aOut: " + angularOutput
	car1.Go(leftPower, rightPower);
End
//--------------------------------------------------------------------------------------------------//
Procedure compass_read
	compass_reading = value.NormalizedMeasurement
	compassRaw = value.RawMeasurement
End
//----------------------------------------------------------------------------------------------------
Procedure laser_read
	//reduce flag if new data arrives
	if(laserReadFlag > 0)
		laserReadFlag = laserReadFlag -1;

	prevFront = frontDist
	
	left1 =value.DistanceMeasurements[360] / 1000.0
	left2 =value.DistanceMeasurements[330] / 1000.0
	right1 =value.DistanceMeasurements[0] / 1000.0
	right2 =value.DistanceMeasurements[30] /1000.0
	frontDist = value.DistanceMeasurements[180] / 1000.0

	call getAngleToWall(left1,left2)
	leftAngle = getAngleToWall
	
	call getAngleToWall(right1,right2)
	rightAngle = - getAngleToWall
	
	call getDistanceToWall(left1,left2)
	leftDist = getDistanceToWall + 0.2 * Math.Sin (leftAngle* Math.PI /180.0)

	call getDistanceToWall(right1,right2)
	rightDist = getDistanceToWall - 0.2 * Math.Sin (rightAngle * Math.PI /180.0)

	dvFront = (frontDist - prevFront)*4
	dpFront = dvFront/kv

	Util.ArrayCopy(value.DistanceMeasurements, rangeData, 361)
End

Procedure getAngleToWall(d1, d2)
	y = d2 * Math.Sin(Math.PI / 12);
	x = d1 - d2 * Math.Cos(Math.PI / 12);
	a = 90-(Math.Atan (y/x )/Math.PI *180.0);
	if (a>=90) 
		a = a-180;
	return a;
End

Procedure getDistanceToWall(d1,d2)
	temp = (d1 - d2 * Math.Cos(Math.PI /12))/(d2*Math.Sin( Math.PI /12));
	return d1/ Math.Sqrt (1 + Math.Pow (temp,2));
End

Procedure proc2
	if(value.Pressed[1])
		robot1 =true
	else
		robot1 = false
	
	if(value.Pressed[2]){
		print compassRaw / Math.PI * 180
		call getWaypointDirection(2)
	}
		
End

Procedure  proc1
	x = value.X
	y = value.Y
		
	x = x * 0.2
	
	leftPower = (-y + x) / 1500.0
	rightPower = (-y - x) / 1500.0

	if(leftPower > 1)
		leftPower = 1
	if(rightPower > 1)
		rightPower = 1


	if(robot1)
		car1.Go(leftPower, rightPower)
End
