DesktopJoystick    joystick1
	/Procedure_UpdateAxes:proc1
	/Procedure_UpdateButtons:proc2
StartSimulationEngine  "SimState/basicsim.xml"
UpdateCameraView
	/EyePosition:0 4 0  	/LookAtPoint:0 0 0
AddNewEntity Wall /Position: 0 0 0
	AddBoxShape  //left wall
		/Position:9    0.2   -1
		/Dimensions:20  0.4  0.2  	/Mass:100000
		//Texture:"ground.bmp"	
	AddBoxShape  //right wall
		/Position:9    0.2   1
		/Dimensions:20  0.4  0.2  	/Mass:100000
		//Texture:"ground.bmp"	
	unit_length = 0.2
	total_length = 20.0
	x_offset = -1.0
	for (int i =0; i<total_length/(unit_length*2.0);i++)
	{
		x = (2*i+1)*unit_length + x_offset;
		AddBoxShape
		/Position: {x} 0.001 0
		/Dimensions: 0.2 0.002 0.1
	}
//Vehicle 1
AddDifferentialDriveEntity    base1
	/Orientation:0    -90.0    0
	/Position:0    0    -0.5
	/Mass: 10
AddLaserRangeFinderEntity    lrf_front
	/Position:0  0.15  -0.25
	/ParentEntity:base1
	/Procedure_SensorNotify: laser_read

AddCompassEntity    compass1
	/Position:-0.1  0.15  -0.25
	/ParentEntity:base1
	/Procedure_SensorNotify: compass_read

//Vehicle 2
AddDifferentialDriveEntity    base2
	/Orientation:0    -90.0    0
	/Position: 4    0    -0.5

//Vehicle 3
AddDifferentialDriveEntity    base3
	/Orientation:0    -90.0    0
	/Position: 0	0    -1.5
	/Position: 3	0    0.5

FlushScript 

robot1 = true
robot2 = false

//Compass global variable
compass_reading = 0

CarWidth = 0.313
HeadingTole = 0.02

//Laser global variables
leftAngle = 0
rightAngle = 0
leftDist =50000
rightDist = 50000
frontDist = 50000
leftBackDist = 50000

dvCar2 = 0 //difference in speed
dvCar3 = 0 

//smoothGo variables
temp = 0
leftWheel = 0
rightWheel = 0
z0 = 0
z1 = 0
middlePoint = 0

// speed - power constant (speed = power x constant)
kv = 1.56
//Control global variables
leftPower = 0;
rightPower = 0;
// Safe distances in metre
front_safe = 0.15
back_safe = 0.15
// vehicle speed while be stable
max_speed = 0.5
cur_speed = 0
// other vehicle speeds - to be computed
car1_speed = 0
car3_speed = 0
// smoothGoTo base speed and needed time (to be computed)
base_turn_power = 0.4
turn_time = 0
// overtaking constants
tmax = 0 // time car 2 runs at max speed
safe_distance = 0
rangeData = Util.CreateArrayDouble(361)

wait 5000
base1.Go(0.1,0.1)
wait 5000
call scanForPlanes(0, 361);
base1.Stop()

Procedure test1
	array1 = Util.CreateArrayDouble(10)
	Util.ArrayCopy(array2, array1, 10)  
	call test2
	print array1[0];
	print array2[0];
End 
Procedure test2
	array2[0] = 100
End

Procedure execute
	while(true)
	{
		if(frontDist > 1.3)
		{
			if(Math.Abs (leftDist - 0.4 ) > 0.1)
			{
				print "Go to middle of land. leftDist: "+ leftDist
				call smoothGoTo(1,0.4 - leftDist,power)
			}
			if(Math.Abs (leftAngle) > 1)
				call correctHeadingLeft(power)

			base1.Go(power)
			wait 100
		}
		else {
			print "overtaking"
			print "frontDist = "+frontDist
			call overtake(power)
		}
	}
End

Procedure overtake(power) 
	dp = dvCar2 / kv
	car2Power= power + dp
	
	call smoothGoTo(1.4,0.7,power)
	call correctHeadingRight(power)

	overtakingPower = 1.25*power

	call estimateSmoothGoTime(1.7,0.7,power)
	t1 = estimateSmoothGoTime

	call estimateSmoothGoTime(1.7,-0.7,power)
	t2 = estimateSmoothGoTime

	t3 = correctHeadingRight*0.25
	print t3

	call estimateOvertakeTime(2, 2, 1.7, 1.7, car2Power, overtakingPower, t1, t2, t3,power)
	tmax = Util.ToInt(estimateOvertakeTime*1000 )
	if (tmax > 0){
		base1.Go(overtakingPower)
		print tmax
		wait tmax
	}
	call smoothGoTo(1.7,-0.7, power)
End

Procedure estimateOvertakeTime(d1,d2,dx1,dx2,P0,Pmax,t1,t2,t3,Pbase)
	V0 = P0 * kv
	Vmax = Pmax*kv
	d3 = t3 * Pbase*kv

	dmax = d1 + d2 + V0*(t1+t2+t3) - dx1 - dx2 - d3
	tmax = dmax/(Vmax - V0)
	return tmax
End

Procedure estimateSmoothGoTime(deltaX,deltaZ,basePower)
	alpha = Math.Asin (( 2*deltaX*deltaZ)/(deltaX*deltaX + deltaZ*deltaZ)) 
	time = 2* alpha * ((deltaX*deltaX + deltaZ*deltaZ)/(4*deltaZ) + 0.1565)/ (basePower*kv)
	return time
End

Procedure correctHeadingLeft(baseSpeed)
	k2 = -0.1/30
	base1.Go(baseSpeed)
	wait 250
	print " ----- correcting heading --------"
	turn = 0
	while(Math.Abs (leftAngle) > 1)
	{
		change = k2 * leftAngle
		print turn + ". leftAngle: " +leftAngle +" => right  += " +change
		base1.Go(baseSpeed-change,baseSpeed+change)
		wait 250
		turn = turn +1
	}
	print " ----- finished correcting heading ---- "
	return turn
End

Procedure correctHeadingRight(baseSpeed)
	k2 = -0.1/30
	base1.Go(baseSpeed)
	wait 250
	print " ----- correcting heading --------"
	turn = 0
	while(Math.Abs (rightAngle) > 1)
	{
		change = k2 * rightAngle
		print turn + ". rightAngle: " +rightAngle +" => right  += " +change
		base1.Go(baseSpeed-change,baseSpeed+change)
		wait 250
		turn = turn +1
	}
	print " ----- finished correcting heading ---- "
	return turn
End

Procedure smoothGoTo(deltaX, deltaZ,basePower)
	print "-----------------------------------------------------------"
	print "Going smoothly to: " + deltaX + " --- " + deltaZ
	orig_heading = compass_reading
	smTemp = Math.Abs((deltaX*deltaX*1.0 + deltaZ*deltaZ*1.0) / (2*CarWidth*deltaZ*1.0))
	target_heading = Math.Abs( Math.Asin( 2*deltaX*deltaZ*1.0 / (deltaX*deltaX*1.0 + deltaZ*deltaZ*1.0) ) / (2*Math.PI))  - HeadingTole
	diff_heading = 0
	if (deltaZ > 0) {
		leftWheel = basePower
		rightWheel = (smTemp - 1) *leftWheel / (smTemp + 1)
		while (diff_heading < target_heading) {
			base1.Go(leftWheel, rightWheel)
			diff_heading = compass_reading - orig_heading
			if (diff_heading < (-0.5))
				diff_heading = diff_heading + 1
		}
		base1.Stop()
		rightWheel = basePower
		leftWheel = (smTemp - 1) * rightWheel / (smTemp + 1)
		while (diff_heading > HeadingTole) {
			base1.Go(leftWheel, rightWheel)
			diff_heading = compass_reading - orig_heading
			if (diff_heading < (-0.5))
				diff_heading = diff_heading + 1
		}
	}
	else {
		rightWheel = basePower
		leftWheel = (smTemp - 1) * rightWheel / (smTemp + 1)
		diff_heading = orig_heading - compass_reading
		while (diff_heading < target_heading) {
			base1.Go(leftWheel, rightWheel)
			diff_heading = orig_heading - compass_reading
			if (diff_heading < (-0.5))
				diff_heading = diff_heading + 1
		}
		base1.Stop()
		leftWheel = basePower
		rightWheel = (smTemp - 1) *leftWheel / (smTemp + 1)
		while (diff_heading > HeadingTole) {
			base1.Go(leftWheel, rightWheel)
			diff_heading = orig_heading - compass_reading
			if (diff_heading < (-0.5))
				diff_heading = diff_heading + 1
		}
	}
	base1.Stop()
End

Procedure scanForPlanes(lower_bound, upper_bound)
	// perpendicular distance to planes
	dir_dist = Util.CreateArrayDouble(10);
	// real distance to planes
	real_dist = Util.CreateArrayDouble(10);
	// angle to planes
	plane_angle = Util.CreateArrayDouble(10);
	array_index = 0;

	localRangeData = Util.CreateArrayDouble(361)
	Util.ArrayCopy(rangeData, localRangeData, 361)  
	count = 0
	count_threshold = 5
	area_threshold = 0.001
	first_index = 0;
	second_index = 0;
	last_index = 0;
	first_area = 0
	bisector = 0
	bh_angle = 0;
	smallest_range_index = 0;

	print "Boundary: (" + lower_bound  + ", " + upper_bound + ")";
	for (i=lower_bound; i < upper_bound; i++) {
		localRangeData[i] = localRangeData[i] / 1000.0;
		if (count == 0) {
		print "----------------"
		print "Index:"  + i + "  range:" + localRangeData[i];
			print "count: 1"
			count ++;
			first_index = i;
			smallest_range_index = i;
			continue;
		}
		else if (count == 1) {
			print "----------------"
			print "Index:"  + i + "  range:" + localRangeData[i];
			print "count: 2"
			count ++;
			second_index = i;
			if (localRangeData[i] < localRangeData[smallest_range_index]) {
				smallest_range_index = i;
			}
			continue;
		}
		else {
			if (first_area == 0) {
				first_area = localRangeData[first_index] * localRangeData[second_index] * Math.Sin( Math.PI / 360.0);
			}
			second_area = localRangeData[second_index] * localRangeData[i] * Math.Sin( Math.PI * (i - second_index) / 360.0);
			full_area = localRangeData[first_index] * localRangeData[i] * Math.Sin( Math.PI * (i - first_index) / 360.0);
			area_diff = Math.Abs (first_area + second_area - full_area);
			if (area_diff < area_threshold) {
				count ++;
				last_index = i;
				if (localRangeData[i] < localRangeData[smallest_range_index]) {
					smallest_range_index = i;
				}
			}
			if ((i == (upper_bound-1)) || (area_diff > area_threshold)) {
				if (count >= count_threshold) {
					// debug printing	
					print "----------------"
					print "Index:"  + i + "  range:" + localRangeData[i];
					print "Areas: " + first_area + "......." + second_area + "........." + full_area;
					print "area_diff: " + area_diff;
					print "count: " + count;	
					print "first_range: " + localRangeData[first_index]
					print "second_range: " + localRangeData[second_index]
					print "last_index: " + last_index;	
					print "last_range: " + localRangeData[last_index]

					// compute the perpendicular distance (dir_dist)
					distance = localRangeData[first_index] * localRangeData[second_index] * Math.Sin( Math.PI / 360.0);
					deno = (localRangeData[first_index] * localRangeData[first_index]) + (localRangeData[second_index] * localRangeData[second_index]);
					deno = deno - (2 * localRangeData[first_index] * localRangeData[second_index] * Math.Cos (Math.PI / 360.0));
					deno = Math.Sqrt (deno);
					distance = distance / deno;
					print "distance: " + distance;
					dir_dist[array_index] = distance;
					// compute the real distance (real_dist)
					real_dist[array_index] = 1.0 * localRangeData[smallest_range_index];
					// compute the angle to the planes
					bisector = 2.0 * localRangeData[first_index] * localRangeData[last_index] * Math.Cos ((last_index - first_index) * Math.PI / 720)
					bisector = bisector / (localRangeData[first_index] + localRangeData[last_index])
					print "bisector: " + bisector;
					bh_angle = Math.Acos (distance / bisector);
					if (localRangeData[last_index] < localRangeData[first_index]) {
						bh_angle = -bh_angle;
					}
					print "bh_angle: " + bh_angle;
					angle = ((first_index + last_index) / 2.0 - 181) * Math.PI / 360.0 - bh_angle;
					angle = angle * 180.0 / Math.PI;
					if (angle > 0) {
						angle = angle - 90;
					}
					else {
						angle = angle + 90;
					}
					plane_angle[array_index] = angle;
					print "array_index: " + array_index
					array_index++;
				}
				first_area = 0;
				first_index = i;
				smallest_range_index = i;
				count = 1;
			}
		}
	}
	print "---------dir_dist--------------"
	for (i = 0; i < 10; i++) {
		print dir_dist[i]
	}
	print "---------real_dist-------------"
	for (i = 0; i < 10; i++) {
		print real_dist[i]
	}
	print "---------plane_angle-----------"
	for (i = 0; i < 10; i++) {
		print plane_angle[i]
	}
	
End

//--------------------------------------------------------------------------------------------------//
Procedure compass_read
	compass_reading = value.NormalizedMeasurement
End

Procedure proc2
	if(value.Pressed[1])
		robot1 =true
	else
		robot1 = false
	if(value.Pressed[2])
		robot2 = true
	else
		robot2 = false
	
End

Procedure  proc1
	x = value.X
	y = value.Y
		
	x = x * 0.2
	
	leftPower = (-y + x) / 1500.0
	rightPower = (-y - x) / 1500.0
	if(robot1)
	{
		base1.Go(leftPower, rightPower)
	}
	if(robot2)
	{
		base2.Go(leftPower,rightPower)
	}
End

//----------------------------------------------------------------------------------------------------

Procedure laser_read
	prevFrontDist = frontDist

	left1 =value.DistanceMeasurements[360] / 1000.0
	left2 =value.DistanceMeasurements[330] / 1000.0
	right1 =value.DistanceMeasurements[0] / 1000.0
	right2 =value.DistanceMeasurements[30] /1000.0
	frontDist = value.DistanceMeasurements[180] / 1000.0

	call getAngleToWall(left1,left2)
	leftAngle = getAngleToWall
	
	call getAngleToWall(right1,right2)
	rightAngle = - getAngleToWall
	
	call getDistanceToWall(left1,left2)
	leftDist = getDistanceToWall + 0.2 * Math.Sin (leftAngle* Math.PI /180.0)

	call getDistanceToWall(right1,right2)
	rightDist = getDistanceToWall - 0.2 * Math.Sin (rightAngle * Math.PI /180.0)

	dvCar2 = (frontDist - prevFrontDist)*4
	//print "distance (left,right):  (" + leftDist+", "+rightDist+")" + "angle: "+leftAngle+", "+ rightAngle
	rightDist = getDistanceToWall
	Util.ArrayCopy(value.DistanceMeasurements, rangeData, 361) 
End
Procedure getAngleToWall(d1, d2)
	y = d2 * Math.Sin(Math.PI / 12);
	x = d1 - d2 * Math.Cos(Math.PI / 12);
	a = 90-(Math.Atan (y/x )/Math.PI *180.0);
	if (a>=90) 
		a = a-180;
	return a;
End
Procedure getDistanceToWall(d1,d2)
	temp = (d1 - d2 * Math.Cos(Math.PI /12))/(d2*Math.Sin( Math.PI /12));
	return d1/ Math.Sqrt (1 + Math.Pow (temp,2));
End

