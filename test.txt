DesktopJoystick    joystick1
	/Procedure_UpdateAxes:proc1
	/Procedure_UpdateButtons:proc2
StartSimulationEngine  "SimState/basicsim.xml"
UpdateCameraView
	/EyePosition:0 10 0  	/LookAtPoint:0 0 0

AddNewEntity Wall /Position: 0 0 0
	AddBoxShape  //left wall
		/Position:9    0.2   -0.8
		/Dimensions:30  0.4  0.2  	/Mass:100000
		//Texture:"ground.bmp"	
	AddBoxShape  //right wall
		/Position:9    0.2   0.8
		/Dimensions:30  0.4  0.2  	/Mass:100000
		//Texture:"ground.bmp"	
	unit_length = 0.2
	total_length = 20.0
	x_offset = -1.0
	for (int i =0; i<total_length/(unit_length*2.0);i++)
	{
		x = (2*i+1)*unit_length + x_offset;
		AddBoxShape
		/Position: {x} 0.001 0
		/Dimensions: 0.2 0.002 0.1
	}
//Vehicle 1
AddDifferentialDriveEntity    base1
	/Orientation:0    -90.0    0
	/Position:0    0    -0.35
	/Mass: 10

AddLaserRangeFinderEntity    lrf_front
	/Position:0  0.15  -0.25
	/ParentEntity:base1
	/Procedure_SensorNotify: laser_read

AddCompassEntity    compass1
	/Position: 0  0.15  -0.25
	/ParentEntity:base1
	/Procedure_SensorNotify: compass_read

//Vehicle 2
AddDifferentialDriveEntity    base2
	/Orientation:0    -90.0    0
	/Position: 10    0    0.35

//Vehicle 3
AddDifferentialDriveEntity    base3
	/Orientation:0    -90.0    0
	/Position: 2	0    -0.35

FlushScript 

robot1 = true
robot2 = false

kv = 1.56 // v = kv * power
BaseTurnSpeed = 0.4
compass_reading = 0
CarWidth = 0.313
HeadingTole = 0.02

leftAngle = 0
rightAngle = 0
leftDist =50000
rightDist = 50000
frontDist = 50000
leftBackDist = 50000

temp = 0
leftWheel = 0
rightWheel = 0
z0 = 0
z1 = 0
middlePoint = 0

wait 1000

call execute(0.4)
//call smoothGoTime(2,0.7,0.4)
//print smoothGoTime

//base3.Go(0.1,0.1)
//call smoothGoTo(2,0.7)
//wait 3798
//base3.Stop()



Procedure execute(speed)
	base1.Go(speed,speed)

	while(true)
	{
		if(frontDist > 1.3)
		{
			if(Math.Abs (leftDist - 0.34) > 0.07)
			{
				print "Go to middle of land. leftDist: "+ leftDist
				call smoothGoTo(1,0.4 - leftDist)
			}
			call correctHeading(speed)
			base1.Go(speed,speed)
			wait 100
		}
		else{
			print "overtaking"
			print "frontDist = "+frontDist
			call smoothGoTo(3.8, 0.8)
			call smoothGoTo(3.8, -0.8)
		}
	}
End

Procedure correctHeading(baseSpeed)
	k2 = -0.1/30
	while(Math.Abs (leftAngle) > 2)
	{
		print " ----- correcting heading --------"
		change = k2 * leftAngle
		print "rightAngle: " +leftAngle +" => change + " +change
		base1.Go(baseSpeed-change,baseSpeed+change)
		wait 100
	}
End

Procedure smoothGoTime(deltaX,deltaZ,baseSpeed)
	alpha = Math.Asin (( 2*deltaX*deltaZ)/(deltaX*deltaX + deltaZ*deltaZ)) 
	print "alpha " + alpha
	time = 2* alpha * ((deltaX*deltaX + deltaZ*deltaZ)/(4*deltaZ) + 0.1565)/ (baseSpeed*kv)
	print "time " + time
	return time
End

Procedure smoothGoTo(deltaX, deltaZ)
	print "-----------------------------------------------------------"
	print "Going smoothly to: " + deltaX + " --- " + deltaZ
	orig_heading = compass_reading
	smTemp = Math.Abs((deltaX*deltaX*1.0 + deltaZ*deltaZ*1.0) / (2*CarWidth*deltaZ*1.0))
	target_heading = Math.Abs( Math.Asin( 2*deltaX*deltaZ*1.0 / (deltaX*deltaX*1.0 + deltaZ*deltaZ*1.0) ) / (2*Math.PI))  - HeadingTole
	diff_heading = 0
	if (deltaZ > 0) {
		leftWheel = BaseTurnSpeed
		rightWheel = (smTemp - 1) *leftWheel / (smTemp + 1)
		while (diff_heading < target_heading) {
			base1.Go(leftWheel, rightWheel)
			diff_heading = compass_reading - orig_heading
			if (diff_heading < (-0.5))
				diff_heading = diff_heading + 1
		}
		base1.Stop()
		rightWheel = BaseTurnSpeed
		leftWheel = (smTemp - 1) * rightWheel / (smTemp + 1)
		while (diff_heading > HeadingTole) {
			base1.Go(leftWheel, rightWheel)
			diff_heading = compass_reading - orig_heading
			if (diff_heading < (-0.5))
				diff_heading = diff_heading + 1
		}
	}
	else {
		rightWheel = BaseTurnSpeed
		leftWheel = (smTemp - 1) * rightWheel / (smTemp + 1)
		diff_heading = orig_heading - compass_reading
		while (diff_heading < target_heading) {
			base1.Go(leftWheel, rightWheel)
			diff_heading = orig_heading - compass_reading
			if (diff_heading < (-0.5))
				diff_heading = diff_heading + 1
		}
		base1.Stop()
		leftWheel = BaseTurnSpeed
		rightWheel = (smTemp - 1) *leftWheel / (smTemp + 1)
		while (diff_heading > HeadingTole) {
			base1.Go(leftWheel, rightWheel)
			diff_heading = orig_heading - compass_reading
			if (diff_heading < (-0.5))
				diff_heading = diff_heading + 1
		}
	}
	base1.Stop()
End


Procedure 
//--------------------------------------------------------------------------------------------------//
Procedure compass_read
	compass_reading = value.NormalizedMeasurement
End
//--------------------------------------------------------------------------------------------------//
Procedure laser_read
	prevFrontDist = frontDist

	left1 =value.DistanceMeasurements[360] / 1000.0
	left2 =value.DistanceMeasurements[330] / 1000.0
	right1 =value.DistanceMeasurements[0] / 1000.0
	right2 =value.DistanceMeasurements[30] /1000.0
	frontDist = value.DistanceMeasurements[180] / 1000.0

	deltaV = (frontDist - prevFrontDist)*4
	//dPower = deltaV / kv
	//print "v = " + deltaV + ", power = "+dPower

	call getAngleToWall(left1,left2)
	leftAngle = getAngleToWall
	
	call getAngleToWall(right1,right2)
	rightAngle = - getAngleToWall
	

	call getDistanceToWall(left1,left2)
	//change coordinate: d = 0.2
	leftDist = getDistanceToWall + 0.2 * Math.Sin (leftAngle* Math.PI /180.0)

	call getDistanceToWall(right1,right2)
	//change coordinate: d =0.2
	rightDist = getDistanceToWall - 0.2 * Math.Sin (rightAngle * Math.PI /180.0)

	//print "distance (left,right):  (" + leftDist+", "+rightDist+")" + "angle: "+leftAngle+", "+ rightAngle
End
Procedure getAngleToWall(d1, d2)
	y = d2 * Math.Sin(Math.PI / 12);
	x = d1 - d2 * Math.Cos(Math.PI / 12);
	a = 90-(Math.Atan (y/x )/Math.PI *180.0);
	if (a>=90) 
		a = a-180;
	return a;
End
Procedure getDistanceToWall(d1,d2)
	temp = (d1 - d2 * Math.Cos(Math.PI /12))/(d2*Math.Sin( Math.PI /12));
	return d1/ Math.Sqrt (1 + Math.Pow (temp,2));
End
//----------------------------------------------------------------------------------------------------
Procedure proc2
	if(value.Pressed[1])
		robot1 =true
	else
		robot1 = false
	if(value.Pressed[2])
		robot2 = true
	else
		robot2 = false
	
	if(value.Pressed[5]){
		call correctHeading(0)
		base1.Stop()
	}
End
Procedure  proc1
	x = value.X
	y = value.Y
		
	x = x * 0.2
	
	leftPower = (-y + x) / 1500.0
	rightPower = (-y - x) / 1500.0
	if(robot1)
	{
		base1.Go(leftPower, rightPower)
	}
	if(robot2)
	{
		base2.Go(leftPower,rightPower)
	}
End