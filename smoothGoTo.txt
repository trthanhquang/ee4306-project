DesktopJoystick    joystick1
	/Procedure_UpdateAxes:proc1
	/Procedure_UpdateButtons:proc2
StartSimulationEngine  "SimState/basicsim.xml"
UpdateCameraView
	/EyePosition:4 8 4  	/LookAtPoint:4 0 0
AddNewEntity Wall /Position: 0 0 0
	AddBoxShape  //left wall
		/Position:30    0.2   -1
		/Dimensions:60  0.4  0.2  	/Mass:100000
		//Texture:"ground.bmp"	
	AddBoxShape  //right wall
		/Position:30    0.2   1
		/Dimensions:60  0.4  0.2  	/Mass:100000
		//Texture:"ground.bmp"	
	unit_length = 0.2
	total_length = 60.0
	x_offset = 0
	for (int i =0; i<total_length/(unit_length*2.0);i++)
	{
		x = (2*i+1)*unit_length + x_offset;
		AddBoxShape
		/Position: {x} 0.001 0
		/Dimensions: 0.2 0.002 0.1
	}
//Vehicle 1
AddDifferentialDriveEntity    base1
	/Orientation:0    -90.0    0
	/Position:1    0    -0.35
	/Mass: 10
AddLaserRangeFinderEntity    lrf_front
	/Position:0  0.15  -0.25
	/ParentEntity:base1
	/Procedure_SensorNotify: laser_read

AddCompassEntity    compass1
	/Position:-0.1  0.15  -0.25
	/ParentEntity:base1
	/Procedure_SensorNotify: compass_read

//Vehicle 2
AddDifferentialDriveEntity    base2
	/Orientation:0    -90.0    0
	/Position: 5    0    -0.35


//Vehicle 3
AddDifferentialDriveEntity    base3
	/Orientation:0    -90.0    0
	/Position: 12	0    -0.35

//Vehicle 4
AddDifferentialDriveEntity    base4
	/Orientation:0    90.0    0
	/Position: 18	0    0.35

//Vehicle 5
AddDifferentialDriveEntity    base5
	/Orientation:0    90.0    0
	/Position: 10	0    0.35


FlushScript 

robot1 = false
robot2 = false
robot3 = false

//Compass global variable
compass_reading = 0

CarWidth = 0.313
HeadingTole = 0.01

//Laser global variables
leftAngle = 0
rightAngle = 0
leftDist =50000
rightDist = 50000
frontDist = 50000
leftBackDist = 50000
rangeData = Util.CreateArrayDouble(361)


planeIndex = Util.CreateArrayDouble(10)
planeAngle = Util.CreateArrayDouble(10)
planeDist = Util.CreateArrayDouble(10)

dvCar2 = 0 //difference in speed
dvCar3 = 0 

//smoothGo variables
temp = 0
leftWheel = 0
rightWheel = 0
z0 = 0
z1 = 0
middlePoint = 0



// speed - power constant (speed = power x constant)
kv = 1.56
//Control global variables
leftPower = 0;
rightPower = 0;


wait 1000
print "3"
wait 1000
print "2"
wait 1000
print "1"
wait 1000
print "GO!"

//base2.Go(0.3)
//base3.Go(0.3)
//base4.Go(0.3)
//base5.Go(0.3)
//call execute(0.8)

Procedure execute(basePower)
{
	while(true){
		call scanForPlanes(0, 361)
		numOfPlanes = scanForPlanes
			
		if((planeIndex[numOfPlanes-2] < 180) && (planeDist[numOfPlanes - 2] > 2)){
			print "freeway!"
			call straightModeLeft(0.5,2,basePower)
			dp = dvCar2 / kv
			car2Power= basePower + dp
			if(car2Power < 0)
				continue;
			print "Detect obstacle at " + frontDist + " ahead, going at P = " + car2Power
					
			print "Car2: "+ planeDist[numOfPlanes - 2]
		}

		//following obstacle
		while(true)
		{
			followingPower = car2Power*1.2
	
			call smoothGoTo(2,0.7 - leftDist,car2Power)
			call correctHeadingLeft(car2Power)
			
			call scanForPlanes(0, 361)
			numOfPlanes = scanForPlanes
			
			if(planeIndex[numOfPlanes-2] > 180)
				print "Car2: "+ planeDist[numOfPlanes - 2]
			
			if(planeDist[numOfPlanes - 2] > 2)
				followingPower = followingPower*1.2
			else
				followingPower = followingPower*0.8

			if((planeIndex[1] < 180) && (planeDist[1] < 9))
			{
				print "Car3: "+ planeDist[1]
				print "Opposite Car too close! --> back to land"
				
				followingPower = (followingPower + car2Power)/2
				call straightModeLeft(0.5,3,followingPower)
			}
			else{
				print "overtake!!!!"
				call overtake(basePower,car2Power)
				break;
			}
		}
	}
}

Procedure straightModeLeft(distToWall, safeDistance, power)
	while(true)
	{
		if(Math.Abs (leftAngle) > 1)
			call correctHeadingLeft(power)
		if(frontDist > safeDistance){
			if(Math.Abs (leftDist - distToWall) > 0.05)
			{
				print "Go to middle of land. leftDist: "+ leftDist
				dz = distToWall - leftDist
				//dx = Math.Abs (40*dz)
				call smoothGoTo(2,dz,power)
			}
			if(Math.Abs (leftAngle) > 1)
				call correctHeadingLeft(power)

			base1.Go(power)
			wait 100
		}
		else
		{
			print "obstacle ahead"
			break;
		}
	}
End



Procedure overtake(power, car2Power) 

	call smoothGoTo(1.4,0.3,power)
	call correctHeadingRight(power)

	overtakingPower = 1.25*power

	call estimateSmoothGoTime(1.4,0.3,power)
	t1 = estimateSmoothGoTime

	call estimateSmoothGoTime(1.4,-0.3,power)
	t2 = estimateSmoothGoTime

	t3 = correctHeadingRight
	print t3

	call estimateOvertakeTime(2, 2, 1.4, 1.4, car2Power, overtakingPower, t1, t2, t3,power)
	print estimateOvertakeTime
	tmax = Util.ToInt(estimateOvertakeTime*1000 )
	if (tmax > 0){
		base1.Go(overtakingPower)
		wait tmax
	}
	call smoothGoTo(1.4,-0.3, power)
End

Procedure estimateOvertakeTime(d1,d2,dx1,dx2,P0,Pmax,t1,t2,t3,Pbase)
	V0 = P0 * kv
	Vmax = Pmax*kv
	d3 = t3 * Pbase*kv

	dmax = d1 + d2 + V0*(t1+t2+t3) - dx1 - dx2 - d3
	tmax = dmax/(Vmax - V0)
	return tmax
End

Procedure estimateSmoothGoTime(deltaX,deltaZ,basePower)
	alpha = Math.Asin (( 2*deltaX*deltaZ)/(deltaX*deltaX + deltaZ*deltaZ)) 
	time = 2* alpha * ((deltaX*deltaX + deltaZ*deltaZ)/(4*deltaZ) + 0.1565)/ (basePower*kv)
	return time
End

Procedure correctHeadingLeftPID(baseSpeed)
	Tu = 1.8 //(s)
	ku = 0.008
	
	kp = ku*0.6
	ki = kp/Tu*2
	kd = kp*Tu*0.125

	errSum = 0
	lastInput = leftAngle

	dt = 100
	turn = 0
	print " ----- correcting heading --------"
	while(Math.Abs (leftAngle) > 1)
	{
		dt = 100
		error = 0-leftAngle
		errSum += error*0.1
		dInput = leftAngle - lastInput
		change = kp * error + ki* errSum - kd*dInput
		lastInput = leftAngle
		
		if(change > 0.1)
			change = 0.1
		if (change < (-0.1))
			change = -0.1
		print turn + ". err= " +error +" => update rightPower:  " +change
//		base1.Go(baseSpeed-change,baseSpeed+change)
		base1.Go(-change,+change)
		wait dt
		turn = turn +1
	}
	t = turn*dt
	print "==> leftAngle: " +leftAngle + ", time spent: " + t + " (ms)"
	print " ----- finished correcting heading ---- "
	return t
End

Procedure correctHeadingLeft(baseSpeed)
	k2 = -0.1/30
	base1.Go(baseSpeed)
	wait 250
	print " ----- correcting heading --------"
	turn = 0
	while(Math.Abs (leftAngle) > 1)
	{
		change = k2 * leftAngle
		print turn + ". leftAngle: " +leftAngle +" => right  += " +change
		base1.Go(baseSpeed-change,baseSpeed+change)
		wait 250
		turn = turn +1
	}
	print turn + ". leftAngle: " +leftAngle
	print " ----- finished correcting heading ---- "
	return turn*0.25
End

Procedure correctHeadingRight(baseSpeed)
	k2 = -0.1/30
	base1.Go(baseSpeed)
	wait 250
	print " ----- correcting heading --------"
	turn = 0
	while(Math.Abs (rightAngle) > 1)
	{
		change = k2 * rightAngle
		print turn + ". rightAngle: " +rightAngle +" => right  += " +change
		base1.Go(baseSpeed-change,baseSpeed+change)
		wait 250
		turn = turn +1
	}
	print turn + ". rightAngle: " +rightAngle
	print " ----- finished correcting heading ---- "
	return turn*0.25
End

Procedure smoothGoTo(deltaX, deltaZ,basePower)
	print "-----------------------------------------------------------"
	print "Going smoothly to: " + deltaX + " --- " + deltaZ + " ---- Power: " + basePower
	orig_heading = compass_reading
	smTemp = Math.Abs((deltaX*deltaX*1.0 + deltaZ*deltaZ*1.0) / (2*CarWidth*deltaZ*1.0))
	target_heading = Math.Abs( Math.Asin( 2*deltaX*deltaZ*1.0 / (deltaX*deltaX*1.0 + deltaZ*deltaZ*1.0) ) / (2*Math.PI))  - HeadingTole
	diff_heading = 0
	if (deltaZ > 0) {
		leftWheel = basePower
		rightWheel = (smTemp - 1) *leftWheel / (smTemp + 1)
		while (diff_heading < target_heading) {
			base1.Go(leftWheel, rightWheel)
			diff_heading = compass_reading - orig_heading
			if (diff_heading < (-0.5))
				diff_heading = diff_heading + 1
		}
		base1.Go(basePower)
		rightWheel = basePower
		leftWheel = (smTemp - 1) * rightWheel / (smTemp + 1)
		while (diff_heading > HeadingTole) {
			base1.Go(leftWheel, rightWheel)
			diff_heading = compass_reading - orig_heading
			if (diff_heading < (-0.5))
				diff_heading = diff_heading + 1
		}
	}
	else {
		rightWheel = basePower
		leftWheel = (smTemp - 1) * rightWheel / (smTemp + 1)
		diff_heading = orig_heading - compass_reading
		while (diff_heading < target_heading) {
			base1.Go(leftWheel, rightWheel)
			diff_heading = orig_heading - compass_reading
			if (diff_heading < (-0.5))
				diff_heading = diff_heading + 1
		}
		base1.Go(basePower)
		leftWheel = basePower
		rightWheel = (smTemp - 1) *leftWheel / (smTemp + 1)
		while (diff_heading > HeadingTole) {
			base1.Go(leftWheel, rightWheel)
			diff_heading = orig_heading - compass_reading
			if (diff_heading < (-0.5))
				diff_heading = diff_heading + 1
		}
	}
	base1.Go(basePower)
End

Procedure scanForPlanes(lower_bound, upper_bound)
	// perpendicular distance to planes
	dir_dist = Util.CreateArrayDouble(10);
	// real distance to planes
	real_dist = Util.CreateArrayDouble(10);
	
	//indexes
	planeStart = Util.CreateArrayDouble(10);
	planeEnd = Util.CreateArrayDouble(10);

	// angle to planes
	plane_angle = Util.CreateArrayDouble(10);
	array_index = 0;

	localRangeData = Util.CreateArrayDouble(361)
	Util.ArrayCopy(rangeData, localRangeData, 361)  
	count = 0
	count_threshold = 5
	area_threshold = 0.002
	first_index = 0;
	second_index = 0;
	last_index = 0;
	first_area = 0
	bisector = 0
	bh_angle = 0;
	smallest_range_index = 0;

	print "Boundary: (" + lower_bound  + ", " + upper_bound + ")";
	for (i=lower_bound; i < upper_bound; i++) {
		localRangeData[i] = localRangeData[i] / 1000.0;
		if (count == 0) {
//		print "----------------"
//		print "Index:"  + i + "  range:" + localRangeData[i];
//			print "count: 1"
			count ++;
			first_index = i;
			smallest_range_index = i;
			continue;
		}
		else if (count == 1) {
//			print "----------------"
//			print "Index:"  + i + "  range:" + localRangeData[i];
//			print "count: 2"
			count ++;
			second_index = i;
			if (localRangeData[i] < localRangeData[smallest_range_index]) {
				smallest_range_index = i;
			}
			continue;
		}
		else {
			if (first_area == 0) {
				first_area = localRangeData[first_index] * localRangeData[second_index] * Math.Sin( Math.PI / 360.0);
			}
			second_area = localRangeData[second_index] * localRangeData[i] * Math.Sin( Math.PI * (i - second_index) / 360.0);
			full_area = localRangeData[first_index] * localRangeData[i] * Math.Sin( Math.PI * (i - first_index) / 360.0);
			area_diff = Math.Abs (first_area + second_area - full_area);
			if (area_diff < area_threshold) {
				count ++;
				last_index = i;
				if (localRangeData[i] < localRangeData[smallest_range_index]) {
					smallest_range_index = i;
				}
			}
			if ((i == (upper_bound-1)) || (area_diff > area_threshold)) {
				if (count >= count_threshold) {
					// debug printing	
//					print "----------------"
//					print "Index:"  + i + "  range:" + localRangeData[i];
//					print "Areas: " + first_area + "......." + second_area + "........." + full_area;
//					print "area_diff: " + area_diff;
//					print "count: " + count;	
//					print "first_range: " + localRangeData[first_index]
//					print "second_range: " + localRangeData[second_index]
//					print "last_index: " + last_index;	
//					print "last_range: " + localRangeData[last_index]
					
					planeStart[array_index] = first_index
					planeEnd[array_index] = last_index

					// compute the perpendicular distance (dir_dist)
					distance = localRangeData[first_index] * localRangeData[second_index] * Math.Sin( Math.PI / 360.0);
					deno = (localRangeData[first_index] * localRangeData[first_index]) + (localRangeData[second_index] * localRangeData[second_index]);
					deno = deno - (2 * localRangeData[first_index] * localRangeData[second_index] * Math.Cos (Math.PI / 360.0));
					deno = Math.Sqrt (deno);
					distance = distance / deno;
//					print "distance: " + distance;
					dir_dist[array_index] = distance;
					// compute the real distance (real_dist)
					real_dist[array_index] = 1.0 * localRangeData[smallest_range_index];
					// compute the angle to the planes
					bisector = 2.0 * localRangeData[first_index] * localRangeData[last_index] * Math.Cos ((last_index - first_index) * Math.PI / 720)
					bisector = bisector / (localRangeData[first_index] + localRangeData[last_index])
									
//					print "bisector: " + bisector;
					div = distance/bisector;
					if(div > 1)
						div = 1
					bh_angle = Math.Acos (div);
					if (localRangeData[last_index] < localRangeData[first_index]) {
						bh_angle = -bh_angle;
					}
//					print "bh_angle: " + bh_angle;
					angle = ((first_index + last_index) / 2.0 - 181) * Math.PI / 360.0 - bh_angle;
					angle = angle * 180.0 / Math.PI;
					if (angle > 0) {
						angle = angle - 90;
					}
					else {
						angle = angle + 90;
					}
					plane_angle[array_index] = angle;
//					print "array_index: " + array_index
					array_index++;
				}
				first_area = 0;
				first_index = i;
				smallest_range_index = i;
				count = 1;
			}
		}
	}
	count = 0;
	for (i = 0; i < 10; i++) {
		if((real_dist[i]!=0) && (Math.Abs ( Math.Abs (plane_angle[i] ) - 90 ) < 10)){
			plane_angle[i] = Util.ToInt(plane_angle[i])
			print "plane: (" +planeStart[i] +", " + planeEnd[i]+ ") plane_angle = "+ plane_angle[i] +"  p_dist = " + dir_dist[i]
			count++;
		}
	}

	Util.ArrayCopy(planeStart, planeIndex, 10)
	Util.ArrayCopy(dir_dist, planeDist, 10)
	Util.ArrayCopy(plane_angle, planeAngle, 10)

	return count
End

Procedure scanForPlanes2(lower_bound, upper_bound)
	print "---------plane_dist--------------"
	count = 0;
	for (i = 0; i < 10; i++) {
		if(plane_dist[i]!=0){
			print "index: " + plane_starting_index[i] + ", d= " + plane_dist[i]
			count++
		}
	}

	return count
End

//--------------------------------------------------------------------------------------------------//
Procedure compass_read
	compass_reading = value.NormalizedMeasurement
	//print "compass_reading: " + compass_reading
	//print value.TimeStamp
End

Procedure proc2
	if(value.Pressed[1])
		robot1 =true
	else
		robot1 = false
	if(value.Pressed[2])
		robot2 = true
	else
		robot2 = false
	if(value.Pressed[3])
		robot3 = true
	else
		robot3 = false
			
	if(value.Pressed[4]){
		print "------ Scan For Plane ------"
		call scanForPlanes(0, 361);
	}

	if(value.Pressed[5])
	{
		print "------ Laser Range Finder ------"
		print "front: " + frontDist
		print "distance (left,right):  (" + leftDist+", "+rightDist+")"
	}

	if(value.Pressed[6]){
		call correctHeadingLeftPID(0.5)
		base1.Stop()
		//base1.Go(0.1,0.1)
	}
	if(value.Pressed[7])
		base1.Turn(30,0.5)
	if(value.Pressed[8])
		call execute(0.7)
End

Procedure  proc1
	x = value.X
	y = value.Y
		
	x = x * 0.2
	
	leftPower = (-y + x) / 1500.0
	rightPower = (-y - x) / 1500.0

	if(leftPower > 1)
		leftPower = 1
	if(rightPower > 1)
		rightPower = 1


	if(robot1)
		base1.Go(leftPower, rightPower)
	if(robot2)
		base2.Go(leftPower,rightPower)
	if(robot3)
		base3.Go(leftPower,rightPower)
End

//----------------------------------------------------------------------------------------------------

Procedure laser_read

	prevFrontDist = frontDist

	left1 =value.DistanceMeasurements[360] / 1000.0
	left2 =value.DistanceMeasurements[330] / 1000.0
	right1 =value.DistanceMeasurements[0] / 1000.0
	right2 =value.DistanceMeasurements[30] /1000.0
	frontDist = value.DistanceMeasurements[180] / 1000.0

	call getAngleToWall(left1,left2)
	leftAngle = getAngleToWall
	
	call getAngleToWall(right1,right2)
	rightAngle = - getAngleToWall
	
	call getDistanceToWall(left1,left2)
	leftDist = getDistanceToWall + 0.2 * Math.Sin (leftAngle* Math.PI /180.0)

	call getDistanceToWall(right1,right2)
	rightDist = getDistanceToWall - 0.2 * Math.Sin (rightAngle * Math.PI /180.0)

	dvCar2 = (frontDist - prevFrontDist)*4

	Util.ArrayCopy(value.DistanceMeasurements, rangeData, 361)
End
Procedure getAngleToWall(d1, d2)
	y = d2 * Math.Sin(Math.PI / 12);
	x = d1 - d2 * Math.Cos(Math.PI / 12);
	a = 90-(Math.Atan (y/x )/Math.PI *180.0);
	if (a>=90) 
		a = a-180;
	return a;
End
Procedure getDistanceToWall(d1,d2)
	temp = (d1 - d2 * Math.Cos(Math.PI /12))/(d2*Math.Sin( Math.PI /12));
	return d1/ Math.Sqrt (1 + Math.Pow (temp,2));
End

