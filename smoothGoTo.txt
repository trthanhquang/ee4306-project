DesktopJoystick    joystick1
	/Procedure_UpdateAxes:proc1
	/Procedure_UpdateButtons:proc2
StartSimulationEngine  "SimState/basicsim.xml"
UpdateCameraView
	/EyePosition:-4 8 1  	/LookAtPoint:4 0 0
AddNewEntity Wall /Position: 0 0 0
	AddBoxShape  //left wall
		/Position:15    0.2   -1
		/Dimensions:40  0.4  0.2  	/Mass:100000
		//Texture:"ground.bmp"	
	AddBoxShape  //right wall
		/Position:15    0.2   1
		/Dimensions:40  0.4  0.2  	/Mass:100000
		//Texture:"ground.bmp"	
	unit_length = 0.2
	total_length = 20.0
	x_offset = -1.0
	for (int i =0; i<total_length/(unit_length*2.0);i++)
	{
		x = (2*i+1)*unit_length + x_offset;
		AddBoxShape
		/Position: {x} 0.001 0
		/Dimensions: 0.2 0.002 0.1
	}
//Vehicle 1
AddDifferentialDriveEntity    base1
	/Orientation:0    -90.0    0
	/Position:0    0    0
	/Mass: 10
AddLaserRangeFinderEntity    lrf_front
	/Position:0  0.15  -0.25
	/ParentEntity:base1
	/Procedure_SensorNotify: laser_read

AddCompassEntity    compass1
	/Position:-0.1  0.15  -0.25
	/ParentEntity:base1
	/Procedure_SensorNotify: compass_read

//Vehicle 2
AddDifferentialDriveEntity    base2
	/Orientation:0    -90.0    0
	/Position: 5    0    -0.5

//Vehicle 3
AddDifferentialDriveEntity    base3
	/Orientation:0    90.0    0
	/Position: 10	0    0.5

FlushScript 

robot1 = false
robot2 = false
robot3 = false

//Compass global variable
compass_reading = 0

CarWidth = 0.313
HeadingTole = 0.01

//Laser global variables
leftAngle = 0
rightAngle = 0
leftDist =50000
rightDist = 50000
frontDist = 50000
leftBackDist = 50000
rangeData = Util.CreateArrayDouble(361)

planeIndex = Util.CreateArrayDouble(10)
planeDist = Util.CreateArrayDouble(10)

dvCar2 = 0 //difference in speed
dvCar3 = 0 

//smoothGo variables
temp = 0
leftWheel = 0
rightWheel = 0
z0 = 0
z1 = 0
middlePoint = 0



// speed - power constant (speed = power x constant)
kv = 1.56
//Control global variables
leftPower = 0;
rightPower = 0;


wait 1000
print "3"
wait 1000
print "2"
wait 1000
print "1"
wait 1000
print "GO!"

basePower = 0.7
base2.Go(0.3)

while(true){
	call straightModeLeft(0.5,3,basePower)
	
	dp = dvCar2 / kv
	car2Power= basePower + dp
	if(car2Power < 0)
		continue;
	print "Detect obstacle at " + frontDist + " ahead, going at P = " + car2Power
	
	while(true)
	{
		call smoothGoTo(2,0.7 - leftDist,car2Power)
		call correctHeadingLeft(car2Power)
		
		call scanForPlanes(0, 361)
		numOfPlanes = scanForPlanes
		
		//if(planeIndex[numOfPlanes-2] > 180)
		//	print "Car2: "+ planeDist[numOfPlanes - 2]
		
		if((planeIndex[1] < 180) && (planeDist[1] < 8))
		{
			print "Car3: "+ planeDist[1]
			print "Opposite Car too close! --> back to land"
			call straightModeLeft(0.5,2,car2Power*1.5)
		}
		else{
			print "overtake!!!!"
			call overtake(basePower,car2Power)
			break;
		}
	}
}

Procedure execute(power)
	base1.Go(power)
	while(true)	{
		if(Math.Abs (leftAngle) > 1)
			call correctHeadingLeft(power)

		if(frontDist > 2 ){
			if(Math.Abs (leftDist - 0.4) > 0.05)
			{
				print "Go to middle of land. leftDist: "+ leftDist
				call smoothGoTo(2,0.4 - leftDist,power)
			}
			if(Math.Abs (leftAngle) > 1)
				call correctHeadingLeft(power)

			base1.Go(power)
			wait 100
		}
		else {
			print "overtaking"
			call scanForPlanes(0, 361)
			call overtake(power)
		}
	}
End

Procedure straightModeLeft(distToWall, safeDistance, power)
	while(true)
	{
		if(Math.Abs (leftAngle) > 1)
			call correctHeadingLeft(power)
		if(frontDist > safeDistance){
			if(Math.Abs (leftDist - distToWall) > 0.05)
			{
				print "Go to middle of land. leftDist: "+ leftDist
				dz = distToWall - leftDist
				//dx = Math.Abs (40*dz)
				call smoothGoTo(2,dz,power)
			}
			if(Math.Abs (leftAngle) > 1)
				call correctHeadingLeft(power)

			base1.Go(power)
			wait 100
		}
		else
		{
			print "obstacle ahead"
			break;
		}
	}
End



Procedure overtake(power, car2Power) 

	call smoothGoTo(1.4,0.3,power)
	call correctHeadingRight(power)

	overtakingPower = 1.25*power

	call estimateSmoothGoTime(1.4,0.3,power)
	t1 = estimateSmoothGoTime

	call estimateSmoothGoTime(1.4,-0.3,power)
	t2 = estimateSmoothGoTime

	t3 = correctHeadingRight*0.25
	print t3

	call estimateOvertakeTime(2, 2, 1.4, 1.4, car2Power, overtakingPower, t1, t2, t3,power)
	print estimateOvertakeTime
	tmax = Util.ToInt(estimateOvertakeTime*1000 )
	if (tmax > 0){
		base1.Go(overtakingPower)
		wait tmax
	}
	call smoothGoTo(1.4,-0.3, power)
End

Procedure estimateOvertakeTime(d1,d2,dx1,dx2,P0,Pmax,t1,t2,t3,Pbase)
	V0 = P0 * kv
	Vmax = Pmax*kv
	d3 = t3 * Pbase*kv

	dmax = d1 + d2 + V0*(t1+t2+t3) - dx1 - dx2 - d3
	tmax = dmax/(Vmax - V0)
	return tmax
End

Procedure estimateSmoothGoTime(deltaX,deltaZ,basePower)
	alpha = Math.Asin (( 2*deltaX*deltaZ)/(deltaX*deltaX + deltaZ*deltaZ)) 
	time = 2* alpha * ((deltaX*deltaX + deltaZ*deltaZ)/(4*deltaZ) + 0.1565)/ (basePower*kv)
	return time
End

//Procedure correctHeadingLeftPI(baseSpeed)
//	kp = -0.0027
//	ki = -0.0018

//	errSum = 0
//	dt = 100
//	turn = 0
//	print " ----- correcting heading --------"
//	while(Math.Abs (leftAngle) > 0.5)
//	{
//		dt = 100
//		error = leftAngle
//		errSum += leftAngle*0.1
//		change = kp * error + ki* errSum
//		print turn + ". err= " +leftAngle +" => update rightPower:  " +change
////		base1.Go(baseSpeed-change,baseSpeed+change)
//		base1.Go(-change,+change)

//		wait dt
//		turn = turn +1
//	}
//	print "==> leftAngle: " +leftAngle
//	print " ----- finished correcting heading ---- "
//	return turn
//End

Procedure correctHeadingLeft(baseSpeed)
	k2 = -0.1/30
	base1.Go(baseSpeed)
	wait 250
	print " ----- correcting heading --------"
	turn = 0
	while(Math.Abs (leftAngle) > 1)
	{
		change = k2 * leftAngle
		print turn + ". leftAngle: " +leftAngle +" => right  += " +change
		base1.Go(baseSpeed-change,baseSpeed+change)
		wait 250
		turn = turn +1
	}
	print turn + ". leftAngle: " +leftAngle
	print " ----- finished correcting heading ---- "
	return turn
End

Procedure correctHeadingRight(baseSpeed)
	k2 = -0.1/30
	base1.Go(baseSpeed)
	wait 250
	print " ----- correcting heading --------"
	turn = 0
	while(Math.Abs (rightAngle) > 1)
	{
		change = k2 * rightAngle
		print turn + ". rightAngle: " +rightAngle +" => right  += " +change
		base1.Go(baseSpeed-change,baseSpeed+change)
		wait 250
		turn = turn +1
	}
	print turn + ". rightAngle: " +rightAngle
	print " ----- finished correcting heading ---- "
	return turn
End

Procedure smoothGoTo(deltaX, deltaZ,basePower)
	print "-----------------------------------------------------------"
	print "Going smoothly to: " + deltaX + " --- " + deltaZ
	orig_heading = compass_reading
	smTemp = Math.Abs((deltaX*deltaX*1.0 + deltaZ*deltaZ*1.0) / (2*CarWidth*deltaZ*1.0))
	target_heading = Math.Abs( Math.Asin( 2*deltaX*deltaZ*1.0 / (deltaX*deltaX*1.0 + deltaZ*deltaZ*1.0) ) / (2*Math.PI))  - HeadingTole
	diff_heading = 0
	if (deltaZ > 0) {
		leftWheel = basePower
		rightWheel = (smTemp - 1) *leftWheel / (smTemp + 1)
		while (diff_heading < target_heading) {
			base1.Go(leftWheel, rightWheel)
			diff_heading = compass_reading - orig_heading
			if (diff_heading < (-0.5))
				diff_heading = diff_heading + 1
		}
		base1.Go(basePower)
		rightWheel = basePower
		leftWheel = (smTemp - 1) * rightWheel / (smTemp + 1)
		while (diff_heading > HeadingTole) {
			base1.Go(leftWheel, rightWheel)
			diff_heading = compass_reading - orig_heading
			if (diff_heading < (-0.5))
				diff_heading = diff_heading + 1
		}
	}
	else {
		rightWheel = basePower
		leftWheel = (smTemp - 1) * rightWheel / (smTemp + 1)
		diff_heading = orig_heading - compass_reading
		while (diff_heading < target_heading) {
			base1.Go(leftWheel, rightWheel)
			diff_heading = orig_heading - compass_reading
			if (diff_heading < (-0.5))
				diff_heading = diff_heading + 1
		}
		base1.Go(basePower)
		leftWheel = basePower
		rightWheel = (smTemp - 1) *leftWheel / (smTemp + 1)
		while (diff_heading > HeadingTole) {
			base1.Go(leftWheel, rightWheel)
			diff_heading = orig_heading - compass_reading
			if (diff_heading < (-0.5))
				diff_heading = diff_heading + 1
		}
	}
	base1.Go(basePower)
End

Procedure scanForPlanes(lower_bound, upper_bound)
	plane_dist = Util.CreateArrayDouble(10);
	plane_starting_index = Util.CreateArrayDouble(10);

	array_index = 0;
	localRangeData = Util.CreateArrayDouble(361)
	Util.ArrayCopy(rangeData, localRangeData, 361)  
	count = 0
	count_threshold = 4
	area_threshold = 0.002
	first_index = 0
	second_index = 0
	first_area = 0

//	print "Boundary: (" + lower_bound  + ", " + upper_bound + ")";
	for (i=lower_bound; i < upper_bound; i++) {
		//print "----------------"
		localRangeData[i] = localRangeData[i] / 1000.0;
		//print "Index:"  + i + "  range:" + localRangeData[i];
		if (count == 0) {
//			print "count: 1"
			count ++;
			first_index = i;
			continue;
		}
		else if (count == 1) {
//			print "count: 2"
			count ++;
			second_index = i;
			continue;
		}
		else {
			if (first_area == 0) {
				first_area = localRangeData[first_index] * localRangeData[second_index] * Math.Sin( Math.PI / 360.0);
			}
			second_area = localRangeData[second_index] * localRangeData[i] * Math.Sin( Math.PI * (i - second_index) / 360.0);
			full_area = localRangeData[first_index] * localRangeData[i] * Math.Sin( Math.PI * (i - first_index) / 360.0);
			//print "Areas: " + first_area + "......." + second_area + "........." + full_area;
			area_diff = Math.Abs (first_area + second_area - full_area);
			//print "area_diff: " + area_diff;
			if (area_diff < area_threshold) {
				count ++;
				//print "count: " + count;
			}
			if ((i == (upper_bound-1)) || (Math.Abs (first_area + second_area - full_area) > area_threshold)) {
				if (count >= count_threshold) {
					halfArea = localRangeData[first_index] * localRangeData[second_index] * Math.Sin( Math.PI / 360.0);
//					print "----------------"
//					print localRangeData[first_index]
//					print localRangeData[second_index]
					base = (localRangeData[first_index] * localRangeData[first_index]) + (localRangeData[second_index] * localRangeData[second_index]);
					base = base - (2 * localRangeData[first_index] * localRangeData[second_index] * Math.Cos (Math.PI / 360.0));
					
					base = Math.Sqrt (base);
//					print halfArea;
//					print base;
					height = halfArea / base;
//					print height
					plane_dist[array_index] = height;
					plane_starting_index[array_index] = first_index;
					array_index++;
//					print "array_index: " + array_index
//					print "first_index: " + first_index
				}

				first_area = 0;
				first_index = i;
				count = 1;
			}
		}
	}
	print "---------plane_dist--------------"
	count = 0;
	for (i = 0; i < 10; i++) {
		if(plane_dist[i]!=0){
			print "index: " + plane_starting_index[i] + ", d= " + plane_dist[i]
			count++
		}
	}
	Util.ArrayCopy(plane_starting_index, planeIndex, 10)
	Util.ArrayCopy(plane_dist, planeDist, 10)
	return count
End

//--------------------------------------------------------------------------------------------------//
Procedure compass_read
	compass_reading = value.NormalizedMeasurement
	//print "compass_reading: " + compass_reading
	//print value.TimeStamp
End

Procedure proc2
	if(value.Pressed[1])
		robot1 =true
	else
		robot1 = false
	if(value.Pressed[2])
		robot2 = true
	else
		robot2 = false
	if(value.Pressed[3])
		robot3 = true
	else
		robot3 = false
			
	if(value.Pressed[4]){
		print "------ Scan For Plane ------"
		call scanForPlanes(0, 361);
	}

	if(value.Pressed[5])
	{
		print "------ Laser Range Finder ------"
		print "front: " + frontDist
		print "distance (left,right):  (" + leftDist+", "+rightDist+")"
	}

	if(value.Pressed[6]){
		call correctHeadingLeft(2)
		base1.Stop()
	}
	if(value.Pressed[7])
		base1.Turn(60,0.5)
End

Procedure  proc1
	x = value.X
	y = value.Y
		
	x = x * 0.2
	
	leftPower = (-y + x) / 1500.0
	rightPower = (-y - x) / 1500.0

	if(leftPower > 1)
		leftPower = 1
	if(rightPower > 1)
		rightPower = 1


	if(robot1)
		base1.Go(leftPower, rightPower)
	if(robot2)
		base2.Go(leftPower,rightPower)
	if(robot3)
		base3.Go(leftPower,rightPower)
End

//----------------------------------------------------------------------------------------------------

Procedure laser_read

	prevFrontDist = frontDist

	left1 =value.DistanceMeasurements[360] / 1000.0
	left2 =value.DistanceMeasurements[330] / 1000.0
	right1 =value.DistanceMeasurements[0] / 1000.0
	right2 =value.DistanceMeasurements[30] /1000.0
	frontDist = value.DistanceMeasurements[180] / 1000.0

	call getAngleToWall(left1,left2)
	leftAngle = getAngleToWall
	
	call getAngleToWall(right1,right2)
	rightAngle = - getAngleToWall
	
	call getDistanceToWall(left1,left2)
	leftDist = getDistanceToWall + 0.2 * Math.Sin (leftAngle* Math.PI /180.0)

	call getDistanceToWall(right1,right2)
	rightDist = getDistanceToWall - 0.2 * Math.Sin (rightAngle * Math.PI /180.0)

	dvCar2 = (frontDist - prevFrontDist)*4

	Util.ArrayCopy(value.DistanceMeasurements, rangeData, 361)
End
Procedure getAngleToWall(d1, d2)
	y = d2 * Math.Sin(Math.PI / 12);
	x = d1 - d2 * Math.Cos(Math.PI / 12);
	a = 90-(Math.Atan (y/x )/Math.PI *180.0);
	if (a>=90) 
		a = a-180;
	return a;
End
Procedure getDistanceToWall(d1,d2)
	temp = (d1 - d2 * Math.Cos(Math.PI /12))/(d2*Math.Sin( Math.PI /12));
	return d1/ Math.Sqrt (1 + Math.Pow (temp,2));
End

